{"version":3,"sources":["@wordpress/e2e-test-utils/src/mocks/set-up-response-mocking.js"],"names":["interceptionInitialized","requestMocks","setUpResponseMocking","mocks","page","setRequestInterception","on","request","i","length","mock","match","onRequestMatch","continue"],"mappings":";;;;AAAA;AACA;AACA;AACA,IAAIA,uBAAuB,GAAG,KAA9B;AAEA;AACA;AACA;;AACA,IAAIC,YAAY,GAAG,EAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAsBC,oBAAtB;AAAA;AAAA;;;mFAAO,kBAAqCC,KAArC;AAAA;AAAA;AAAA;AAAA;AAAA,gBACCH,uBADD;AAAA;AAAA;AAAA;;AAEL;AACA;AACAA,YAAAA,uBAAuB,GAAG,IAA1B;AAJK;AAAA,mBAKCI,IAAI,CAACC,sBAAL,CAA6B,IAA7B,CALD;;AAAA;AAMLD,YAAAA,IAAI,CAACE,EAAL,CAAS,SAAT;AAAA,kFAAoB,iBAAQC,OAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AACTC,wBAAAA,CADS,GACL,CADK;;AAAA;AAAA,8BACFA,CAAC,GAAGP,YAAY,CAACQ,MADf;AAAA;AAAA;AAAA;;AAEZC,wBAAAA,IAFY,GAELT,YAAY,CAAEO,CAAF,CAFP;;AAAA,6BAGbE,IAAI,CAACC,KAAL,CAAYJ,OAAZ,CAHa;AAAA;AAAA;AAAA;;AAAA;AAAA,+BAIXG,IAAI,CAACE,cAAL,CAAqBL,OAArB,CAJW;;AAAA;AAAA;;AAAA;AACuBC,wBAAAA,CAAC,EADxB;AAAA;AAAA;;AAAA;AAQnBD,wBAAAA,OAAO,CAACM,QAAR;;AARmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAApB;;AAAA;AAAA;AAAA;AAAA;;AANK;AAiBN;AACA;AACAZ,YAAAA,YAAY,sBAAQE,KAAR,CAAZ;;AAnBM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/**\n * Track if we have already initialized the request interception.\n */\nlet interceptionInitialized = false;\n\n/**\n * Array of mock responses.\n */\nlet requestMocks = [];\n\n/**\n * Sets up mock checks and responses. Accepts a list of mock settings with the following properties:\n *\n * - `match`: function to check if a request should be mocked.\n * - `onRequestMatch`: async function to respond to the request.\n *\n * @example\n *\n * ```js\n * const MOCK_RESPONSES = [\n *   {\n *     match: isEmbedding( 'https://wordpress.org/gutenberg/handbook/' ),\n *     onRequestMatch: JSONResponse( MOCK_BAD_WORDPRESS_RESPONSE ),\n *   },\n *   {\n *     match: isEmbedding( 'https://wordpress.org/gutenberg/handbook/block-api/attributes/' ),\n *     onRequestMatch: JSONResponse( MOCK_EMBED_WORDPRESS_SUCCESS_RESPONSE ),\n *   }\n * ];\n * setUpResponseMocking( MOCK_RESPONSES );\n * ```\n *\n * If none of the mock settings match the request, the request is allowed to continue.\n *\n * @param {Array} mocks Array of mock settings.\n */\nexport async function setUpResponseMocking( mocks ) {\n\tif ( ! interceptionInitialized ) {\n\t\t// We only want to set up the request interception once, or else we get a crash\n\t\t// when we try to process the same request twice.\n\t\tinterceptionInitialized = true;\n\t\tawait page.setRequestInterception( true );\n\t\tpage.on( 'request', async ( request ) => {\n\t\t\tfor ( let i = 0; i < requestMocks.length; i++ ) {\n\t\t\t\tconst mock = requestMocks[ i ];\n\t\t\t\tif ( mock.match( request ) ) {\n\t\t\t\t\tawait mock.onRequestMatch( request );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\trequest.continue();\n\t\t} );\n\t}\n\t// Overwrite with the passed in mocks, so we can change the mocks mid-test to test\n\t// recovery from scenarios where a request had failed, but is working again.\n\trequestMocks = [ ...mocks ];\n}\n"]}